---
description: 
globs: 
alwaysApply: true
---
Flutter App Architecture Guidelines for Senior/Expert Developers
Creating a well-structured Flutter app requires thoughtful architecture decisions that maintain consistency and minimize code duplication. Below are guidelines specifically focused on cursor management, widget reusability, theming, and routing for senior Flutter developers.
Core Architecture Guidelines
1. Widget Organization

Keep all reusable widgets in lib/widgets/ directory
Group related widgets in subfolders (e.g., lib/widgets/input/, lib/widgets/cards/)
Create abstract base widgets that can be extended for specific use cases
Implement widget factories for components that have multiple variations

2. Theming Strategy

Centralize all theme definitions in lib/theme.dart
Create extension methods on ThemeData for custom theme properties
Define semantic color constants (e.g., primaryActionColor instead of just blue)
Use theme inheritance for variant themes (dark mode, high contrast)

3. Routing System

Centralize route definitions in lib/main.dart
Use named routes for better maintainability
Implement route guards for authentication/authorization where needed
Consider using route generation for complex navigation patterns

Cursor Management Best Practices
1. Text Input Focus

Create a FocusManager service to handle app-wide focus changes
Use FocusScopeNode to manage focus within forms or complex input areas
Implement keyboard navigation helpers for form fields
Create custom focus traversal policies for complex forms

2. Selection and Cursor Position

Develop reusable TextEditingController extensions for common cursor operations
Create a CursorPosition model class to maintain and restore cursor state
Implement serialization of cursor position for state persistence
Use SelectionDelegate pattern for custom selection behaviors

3. Drag Operations

Implement a consistent drag-and-drop architecture across the app
Create a DragContext class to maintain drag state
Use cursor style changes to indicate draggable/droppable states
Implement haptic feedback for drag operations

UI Consistency Guidelines
1. Design System Implementation

Create atomic design components (atoms, molecules, organisms)
Implement a design token system in the theme
Use composition over inheritance for widget customizations
Create builder patterns for complex widget configurations

2. State Management for UI

Use controlled components pattern for input fields
Separate presentation logic from business logic
Implement ValueNotifier or streams for fine-grained UI updates
Create view models that transform business data into UI-ready formats

3. Responsive Design

Use LayoutBuilder for responsive layouts
Create adaptive widgets that respond to available space
Implement responsive grid systems
Use fractional sizing when appropriate

Slicing and UI Development Workflow
1. Component-First Approach

Develop UI components in isolation before integration
Create a component gallery page for visual testing
Implement storybook-like patterns for component variants
Document component APIs with examples

2. Design-to-Code Process

Create a design token extraction process from design files
Use automated tools to generate boilerplate widget code
Implement design-to-code validation tests
Create pixel-perfect testing utilities

3. UI Performance Optimization

Use RepaintBoundary strategically to minimize repaints
Implement lazy loading patterns for list items
Optimize image loading and caching
Create performance profiles for key screens

Additional Recommendations
1. Code Generation for Boilerplate

Use build_runner with code generators for repetitive patterns
Create custom annotations for widget documentation
Generate theme extensions automatically from design tokens
Implement automated route generation

2. Testing Strategy

Create widget testing helpers for common patterns
Implement golden tests for visual regression testing
Use fake/mock services for widget testing
Create screenshot testing for critical UI flows

3. Documentation

Document widget usage patterns with examples
Create internal design system documentation
Implement automated API docs generation

Maintain a style guide for custom widgets